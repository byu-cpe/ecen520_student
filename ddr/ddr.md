
# DDR

In this assignment you will generate a DDR controller from the IP generator tool and use this controller to read and write data from a DDR memory.

## DDR Controller IP

The first part of this assignment is to generate a DDR controller using the IP generator tool in Vivado and simulate/build the DDR demo design for the Nexys4 DDR board.
Instructions for completing this portion of the assignment can be found in the [IP](ip/ip.md) section of the assignment.
All the files needed for this part of the assignment can be found in the [ip](ip) directory.
You should create the DDR IP in this directory and then use this generated IP for your assignment submission.

There are several makefile rules that you need to add in the `ip/makefile` to help you manage the IP generation and example design creation.
Make sure you have all of these rules implemented.
* `make_ip` generates `./ip/mig_7series_0/mig_7series_0/user_design/rtl/mig_7series_0.v`
* `clean_ip` removes the generated IP directories
* `make_example` rule that creates the example design. generates `./ip/example_design/mig_7series_0_ex/imports/example_top.v`
* `clean_example` rule that deletes the `example_design` directory.
Add the following rules in the `ip/makefile`:
* A `make_example_bit` rule that creates a bitfile for the example design.
* A `clean` rule that cleans everything in the `ip` directory.


There are a number of questions that you need to complete as part of the report for this part of the assignment.
Add these responses to your report file.

Make sure you go through this exercise carefully as the understanding you develop during this exercise will be important for the second part of the assignment.

## DDR UART FIFO

For the second part of the assignment you will create a new design that uses the DDR controller to implement a FIFO in the DDR much like you did with the BRAM assignment.
This design will be similar to the example design created in the previous exercise of this assignment but will need to be modified to implement the functionality described below.

### DDR Top-Level Template

A top-level design named [`ddr_top_template.sv`](./ddr_top_template.sv) has been provided to you to help you get started.
This design template provides the top-level ports and instantiates the DDR memory controller IP to save you some time.
Rename this file to `ddr_top.sv` and place your logic within this file.
This section wil describe several important details about this top-level design template.

**Clocks and Resets**

The design has several clocks and their associated resets and it is important to understand the purpose of each.
* **`CLK100MHz`**: This is the 100 MHz clock provided by the Nexys4 DDR board.
  * A reset synchronizer circuit is provided that generates the `clk100_rst` reset signal for this clock domain.
  * The primary purpose of this clock domain is to drive the MMCM that generates the 200 MHz clock needed by the DDR controller. Unlike previous designs, you will not be using this clock domain for any other logic in your design.
* **`clk200`**: This is a 200 MHz clock generated by the MMCM. It is used to drive the DDR memory controller.
  * The reset for this clock is the `clk200_reset` signal generated from the MMCM locked signal.
  * You will not be using this clock domain for your logic.
* **`axi_clk`**: This is the AXI clock generated by the DDR memory controller. You will use this clock domain for all your logic.
  * The reset for this clock is the `axi_clk_rst` signal generated by the DDR controller

**Memory Interface**

The DDR memory is 128 MB in size.
The AXI address busses (`s_axi_awaddr` and `s_axi_araddr`) for the DDR controller are 27 bits wide which provides access to 2^27 = 134,217,728 bytes of memory (128 MB).
The address busses are byte addressable meaning that each address points to an individual byte in memory.
The AXI data bus is 128 bits wide (16 bytes).
Every read or write transaction will involve reading or writing 16 bytes of data at a time.

The DDR memory controller uses an AXI4 interface for reading and writing data.
The controller is the 'slave' and your circuit is the 'master' for this interface.
You will need to design your logic to drive this interface to read and write data from the DDR memory (this is opposite from the UART AXI interface where the UART was the slave side).
In particular, you will need to interface to the following signals when you create your AXI master interface:
* Address Write channel
  * `s_axi_awaddr`: You will drive the address for writing (27 bits)
  * `s_axi_awvalid`: You will indicate when the address is valid
  * `s_axi_awready`: You will need to watch for the ready response.
  * All other signals have been hard coded for single transfers.
* Data Write channel
  * `s_axi_wdata`: The data you are writing. Note that this is 128 bits (16 bytes). You will only be writing 8 bits (1 byte) and you need to place the byte you are writing in to the correct byte based on the write address (i.e., writing a  byte to address 0 will required the byte to be located at bits 7:0, writing to address 1 will require the byte to be located at bits 15:8, and so on).
  * `s_axi_wstrb`: 16 bit ata write strobe. This indicates which bytes are to be written. In our case when we are only writing one byte at a time, only one of the 16 bits will be asserted at a time. When writing data at the lowest byte (7:0), `s_axi_wstrb = 16'h0001`. When writing data at the next byte (15:8) `s_axi_wstrb = 16'h0002` and so on.
  * `s_axi_wvalid`: handshaking: you drive
  * `s_axi_wready`: handshaking: you read
* Write response channel
  * `s_axi_bvalid`: handshaking: you read
  * `s_axi_bready`: handshaking: you drive
* Address Read Channel
  * `s_axi_araddr`: You will drive the address for writing (27 bits)
  * `s_axi_arvalid`: You will indicate when the address is valid
  * `s_axi_arready`: You will need to watch for the ready response.
  * All other signals have been hard coded for single transfers.
* Read Data Channel
  * `s_axi_rdata`: The data you get back from the controller. Note that this is 128 bits (16 bytes). You will only be reading 8 bits (1 byte) at a time. You need to select the appropriate byte within the 128 when you are capturing data from this bus.
  * `s_axi_rvalid`: handshaking: you read
  * `s_axi_rready`: handshaking: you drive

Note that the `init_calilb_complete` signal is ited to the `LED16_B` pin so you can verify that the DDR is calibrated.

### Top-Level Design

For this top-level design, implement a UART FIFO like was done in the BRAM assignment.
The details of this design are as follows:
* All logic you create should be based on the `axi_clk` signal (the resets should use the `axi_rst` signal)
* Instance your UART receiver and transmitter. Set the values of the BAUD rate and parity as specified in the parameters of the top-level design. **NOTE**. The clock rate of the `axi_clk` used in your design is 75 MHz. Make sure you set the clock frequency to these cores properly.
* Every time you receive a character over the UART recevier, issue an AXI write command to the DDR.
* Create a state machine that implements the following:
  * Do not proceed in your state machine until the `init_calib_complete` signal is asserted
  * When a character is received from the UART receiver, write the character to the DDR at the address specific by the write address register. Increment this address.
  * When BTNC is pressed, read the full DDR FIFO and send each character one at a time to the UART transmitter until the read_address equals the write_address.
  * Create a write address register that is one bit larger than the address width of the DDR controller. Use this address to write data to the DDR controller (except for the most significant bit). Every time a write occurs, increment this address so that the next write will be written to the next location
  * Create a read counter that is one bit larger than the address width of the DDR controller. Use this address to write data to the DDR controller (except for the most significant bit).
  * Create an empty flag that is asserted when the write address is equal to the read address (including the most significant bit).
  * Create an full flag that is asserted when the write address is equal to the read address and the most significant bit is different.
* BTNU should be used to reset your write address and read address so that the FIFO is empty

## DDR UART FIFO Simulation

A top-level testbench has been created for you named `ddr_top_tb.sv` (this will save you a lot of time!).
Simulate your design to make sure that it properly writes characters received from the testbench and then reads them and retransmits them when BTNC is pressed.
Create a makefile rule `sim_ddr_uart_top` that performs this simulation.

## DDR UART FIFO Bitfile Generation

Create a synthesis script that will synthesis your design and generate a bitfile named `ddr_fifo_top.bit`.
Create a makefile rule `gen_bit` that performs this task.

Make sure your bitstream operates correctly on the board.

## Submission

The following assignment specific items should be included in your repository:

1. Required Makefile rules:
  * `sim_ddr_uart_top`
  * `gen_bit`
2. You need to have at least 4 "Error" commits in your repository
3. Assignment specific Questions:
  * "DDR Controller IP" Questions

<!--
Changes:
- Use an AXI interface instead of this odd "UI" interface that is hard to understand and difficult to use (it forces students to learn about AXI)
- Figure out a way to build the project using an envhiroinment variable pointing to the simulation libraries. I was forced to build this on the digital labs because these libraries were hard coded
- Adrianna and Michael's designs didn't work. Odd behvaior that I couldn't figure out. Need more debuggging experience to help with these problems.
- Provide more discussion about the clock domains and approaches for handling the clock domains (which clock is Tx/rx? need to know clocks of these)
- Need to provide a template for the quyestios so it is easier to grade
- Is there a way we can reduce the number of warnings?
- Need to be more clear on what should be printed for the simulation and testbench for grading. Perhaps a header for ease of grading and finding results.

- Student comments:
* If you could put in the ddr.md that `[0:0]` has to be included before some of the ports in our top module that would be great. As it appears to be redundant so multiple of us have removed it, but it has to be there or it causes a lot of weird issues.
* took a very long time figuring out the file structures and getting the IP to implement together
* The disparity between simulation and implementation, where my first printed character would be replaced by the most recent character in its same column number (despite being if a different row), caused many additional hours of debugging with little to go on.
  * It may be helpful to give a more in dept explainaiton in the lab write up of the DDR
-->