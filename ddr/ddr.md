
# DDR

In this assignment you will generate a DDR controller from the IP generator tool and use this controller to read and write data from a DDR memory.

## DDR Controller IP

The first part of this assignment is to generate a DDR controller using the IP generator tool in Vivado and simulate/build the DDR demo design for the Nexys4 DDR board.
Instructions for completing this portion of the assignment can be found in the [IP](ip/ip.md) section of the assignment.
All the files needed for this part of the assignment can be found in the [ip](ip) directory.
You should create the DDR IP in this directory and then use this generated IP for your assignment submission.

There are several makefile rules that you need to add in the `ip/makefile` to help you manage the IP generation and example design creation.
Make sure you have all of these rules implemented.
* `make_ip` generates `./ip/mig_7series_0/mig_7series_0/user_design/rtl/mig_7series_0.v`
* `clean_ip` removes the generated IP directories
* `make_example` rule that creates the example design. generates `./ip/example_design/mig_7series_0_ex/imports/example_top.v`
* `clean_example` rule that deletes the `example_design` directory.
Add the following rules in the `ip/makefile`:
* A `make_example_bit` rule that creates a bitfile for the example design.
* A `clean` rule that cleans everything in the `ip` directory.


There are a number of questions that you need to complete as part of the report for this part of the assignment.
Add these responses to your report file.

Make sure you go through this exercise carefully as the understanding you develop during this exercise will be important for the second part of the assignment.

## DDR UART FIFO

For the second part of the assignment you will create a new design that uses the DDR controller to implement a FIFO in the DDR much like you did with the BRAM assignment.
This design will be similar to the example design created in the previous exercise of this assignment but will need to be modified to implement the functionality described below.

### DDR Top-Level Template

A top-level design named [`ddr_top_template.sv`](./ddr_top_template.sv) has been provided to you to help you get started.
This design template provides the top-level ports and instantiates the DDR memory controller IP to save you some time.
Rename this file to `ddr_top.sv` and place your logic within this file.
This section wil describe several important details about this top-level design template.

**Clocks and Resets**

The design has several clocks and their associated resets and it is important to understand the purpose of each.
* **`CLK100MHz`**: This is the 100 MHz clock provided by the Nexys4 DDR board.
  * A reset synchronizer circuit is provided that generates the `clk100_rst` reset signal for this clock domain.
  * The primary purpose of this clock domain is to drive the MMCM that generates the 200 MHz clock needed by the DDR controller. Unlike previous designs, you will not be using this clock domain for any other logic in your design.
* **`clk200`**: This is a 200 MHz clock generated by the MMCM. It is used to drive the DDR memory controller.
  * The reset for this clock is the `clk200_reset` signal generated from the MMCM locked signal.
  * You will not be using this clock domain for your logic.
* **`axi_clk`**: This is the AXI clock generated by the DDR memory controller. You will use this clock domain for your logic.
  * The reset for this clock is the `axi_clk_rst` signal generated by the DDR controller

**Memory Interface**

The DDR memory is 128 MB in size.
The AXI address busses (`s_axi_awaddr` and `s_axi_araddr`) for the DDR controller are 27 bits wide which provides access to 2^27 = 134,217,728 bytes of memory (128 MB).
The address busses are byte addressable meaning that each address points to an individual byte in memory.
The AXI data bus is 128 bits wide (16 bytes).
Every read or write transaction will involve reading or writing 16 bytes of data at a time.

Reading data (zero alinged)

Wrinting data (must put it in its proper place)


**AXI Master Interface**

The DDR memory controller uses an AXI4 interface for reading and writing data.
The controller is the 'slave' and your circuit is the 'master' for this interface.
You will need to design your logic to drive this interface to read and write data from the DDR memory (this is opposite from the UART AXI interface where the UART was the slave side).




## Top-Level Design

For this top-level design, implement a UART FIFO like was done in the BRAM assignment.
Specifically, accept characters from your UART RX and when received write them sequentially into the DDR.

**TODO**

* BTNC: stream FIFO out over tx
* BTND: reset the FIFOs


Create a top-level design named `ddr_uart_fifo.sv` that does the following:
* Instance your UART receiver and transmitter. Set the values of the BAUD rate and parity as specified in the parameters of the top-level design
* Create the FIFO functionality for the DDR as follows (you do not necessarily need to create a new module for this):
  * Create a write address register that is one bit larger than the address width of the DDR controller. Use this address to write data to the DDR controller (except for the most significant bit).
  * Create a read counter that is one bit larger than the address width of the DDR controller. Use this address to write data to the DDR controller (except for the most significant bit).
  * Create an empty flag that is asserted when the write address is equal to the read address (including the most significant bit).
  * Create an full flag that is asserted when the write address is equal to the read address and the most significant bit is different.
* Create a state machine that implements the following:
  * Do not proceed in your state machine until the `init_calib_complete` signal is asserted
  * When a character is received from the UART receiver, write the character to the DDR at the address specific by the write address register. Increment this address.
  * When BTNC is pressed, read the full DDR FIFO and send each character one at a time to the UART transmitter. 
* Instance your seven segment display controller and display the number of characters received from the UART receiver. This count should be the total sum of characters received and does not need to be reset after the FIFO buffer has been transferred.
* If BTNU is pressed, reset the DDR FIFO counters (i.e., ignore all the data that is in the FIFO). Do not reset the number of characters received counter.
* Display the `init_calib_complete` signal on `LED16_B`


## DDR UART FIFO Simulation

Create a top-level testbench in a file named `ddr_uart_fifo_tb.sv` that simulates the design in command line mode.
Instance your top-level design, the DDR memory controller, and the UART receiver and transmitter.
Design your testbench to do the following;
* Wait until the `init_calib_complete` signal is asserted
* Write several characters to the design by sending data over your transmitter. Print a message to the console when each character is sent.
* Press BTNC to read the data back from the DDR FIFO. Print a message to the console when each character is receivfed

Create a makefile rule `sim_ddr_uart_top` that performs this simulation.

## DDR UART FIFO Bitfile Generation

Create a synthesis script that will synthesis your design and generate a bitfile named `ddr_fifo_top.bit`.
Create a makefile rule `gen_bit` that performs this task.

Make sure your bitstream operates correctly on the board.

## Submission

The following assignment specific items should be included in your repository:

1. Required Makefile rules:
  * `sim_ddr_uart_top`
  * `gen_bit`
2. You need to have at least 4 "Error" commits in your repository
3. Assignment specific Questions:
  * "DDR Controller IP" Questions

<!--
Changes:
- Use an AXI interface instead of this odd "UI" interface that is hard to understand and difficult to use (it forces students to learn about AXI)
- Figure out a way to build the project using an envhiroinment variable pointing to the simulation libraries. I was forced to build this on the digital labs because these libraries were hard coded
- Adrianna and Michael's designs didn't work. Odd behvaior that I couldn't figure out. Need more debuggging experience to help with these problems.
- Provide more discussion about the clock domains and approaches for handling the clock domains (which clock is Tx/rx? need to know clocks of these)
- Need to provide a template for the quyestios so it is easier to grade
- Is there a way we can reduce the number of warnings?
- Need to be more clear on what should be printed for the simulation and testbench for grading. Perhaps a header for ease of grading and finding results.

- Student comments:
* If you could put in the ddr.md that `[0:0]` has to be included before some of the ports in our top module that would be great. As it appears to be redundant so multiple of us have removed it, but it has to be there or it causes a lot of weird issues.
* took a very long time figuring out the file structures and getting the IP to implement together
* The disparity between simulation and implementation, where my first printed character would be replaced by the most recent character in its same column number (despite being if a different row), caused many additional hours of debugging with little to go on.
  * It may be helpful to give a more in dept explainaiton in the lab write up of the DDR
-->